<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pronunciation Practice</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        .modal-content {
          padding: 20px;
          width: 95%;
        }

        async warmUpSpeechSynthesis() {
          return new Promise((resolve) => {
            // Create a silent warm-up utterance to initialize speech synthesis
            const warmUpUtterance = new SpeechSynthesisUtterance(" ");
            warmUpUtterance.volume = 0; // Silent
            warmUpUtterance.rate = 1;
            warmUpUtterance.pitch = 1;

            // Wait for voices to be loaded
            const voices = speechSynthesis.getVoices();
            if (voices.length > 0) {
              const englishVoice = voices.find(voice => 
                voice.lang.startsWith('en') && voice.localService
              ) || voices.find(voice => 
                voice.lang.startsWith('en')
              ) || voices[0];
              
              warmUpUtterance.voice = englishVoice;
            }

            warmUpUtterance.onend = () => {
              setTimeout(resolve, 100);
            };
            warmUpUtterance.onerror = () => {
              setTimeout(resolve, 100);
            };

            // Cancel any existing speech and start warm-up
            if (speechSynthesis.speaking) {
              speechSynthesis.cancel();
            }
            
            setTimeout(() => {
              speechSynthesis.speak(warmUpUtterance);
            }, 50);
          });
        }

        openModal() {
          this.settingsModal.classList.add("show");
          document.body.style.overflow = "hidden"; // Prevent background scrolling
        }

        closeModal() {
          this.settingsModal.classList.remove("show");
          document.body.style.overflow = "auto"; // Restore scrolling
        }

        .modal-header h2 {
          font-size: 1.3rem;
        }
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: white;
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        text-align: center;
        max-width: 400px;
        width: 100%;
      }

      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 30px;
      }

      h1 {
        color: #333;
        font-size: 1.8rem;
        margin: 0;
      }

      .settings-btn {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: #667eea;
        cursor: pointer;
        padding: 8px;
        border-radius: 50%;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .settings-btn:hover {
        background: rgba(102, 126, 234, 0.1);
        transform: rotate(90deg);
      }

      .word-display {
        font-size: 2.5rem;
        font-weight: bold;
        color: #667eea;
        margin: 20px 0;
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .practice-info {
        font-size: 1rem;
        color: #666;
        margin: 15px 0;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 8px;
        border-left: 4px solid #667eea;
      }

      .start-btn {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        border-radius: 50%;
        width: 120px;
        height: 120px;
        color: white;
        font-size: 1.2rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 20px 0;
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
      }

      .start-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 30px rgba(102, 126, 234, 0.4);
      }

      .start-btn:active {
        transform: translateY(0);
      }

      .start-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .status {
        font-size: 1.1rem;
        margin: 20px 0;
        min-height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .listening {
        color: #e74c3c;
        animation: pulse 1.5s infinite;
      }

      .speaking {
        color: #27ae60;
      }

      .playing {
        color: #f39c12;
      }

      .waiting {
        color: #3498db;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .progress {
        background: #ecf0f1;
        border-radius: 10px;
        height: 8px;
        margin: 20px 0;
        overflow: hidden;
      }

      .progress-bar {
        background: linear-gradient(90deg, #667eea, #764ba2);
        height: 100%;
        width: 0%;
        transition: width 0.3s ease;
      }

      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.5);
        animation: fadeIn 0.3s ease;
      }

      .modal.show {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .modal-content {
        background-color: white;
        margin: auto;
        padding: 30px;
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        width: 90%;
        max-width: 500px;
        position: relative;
        animation: slideIn 0.3s ease;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes slideIn {
        from { 
          opacity: 0;
          transform: translateY(-50px) scale(0.9);
        }
        to { 
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #f0f0f0;
      }

      .modal-header h2 {
        color: #333;
        margin: 0;
        font-size: 1.5rem;
      }

      .close-btn {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: #999;
        cursor: pointer;
        padding: 5px;
        border-radius: 50%;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 35px;
        height: 35px;
      }

      .close-btn:hover {
        background: rgba(231, 76, 60, 0.1);
        color: #e74c3c;
      }

      .modal-controls {
        display: grid;
        grid-template-columns: 1fr;
        gap: 20px;
      }

      .modal-control-group {
        text-align: left;
      }

      .modal-control-group label {
        display: block;
        font-size: 1rem;
        color: #333;
        margin-bottom: 8px;
        font-weight: 500;
      }

      .modal-control-group input {
        width: 100%;
        padding: 12px;
        border: 2px solid #ecf0f1;
        border-radius: 10px;
        font-size: 1rem;
        transition: border-color 0.3s ease;
      }

      .modal-control-group input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .new-words-btn {
        background: linear-gradient(135deg, #27ae60, #2ecc71);
        border: none;
        border-radius: 8px;
        padding: 10px 15px;
        color: white;
        font-size: 0.9rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: 15px;
        box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
      }

      .new-words-btn:hover {
        background: linear-gradient(135deg, #2ecc71, #27ae60);
        transform: translateY(-1px);
        box-shadow: 0 6px 12px rgba(39, 174, 96, 0.4);
      }

      .new-words-btn:active {
        transform: translateY(0);
      }
        .container {
          padding: 20px;
        }

        h1 {
          font-size: 1.5rem;
        }

        .word-display {
          font-size: 2rem;
        }

        .start-btn {
          width: 100px;
          height: 100px;
          font-size: 1rem;
        }

      @media (max-width: 480px) {
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üé§ Pronunciation Practice</h1>
        <button class="settings-btn" id="settingsBtn">‚öôÔ∏è</button>
      </div>

      <div class="word-display" id="wordDisplay">Ready to start!</div>

      <div class="practice-info" id="practiceInfo">Practice 10 random words</div>

      <button class="start-btn" id="startBtn">START</button>

      <div class="status" id="status">Click START to begin</div>

      <div class="progress">
        <div class="progress-bar" id="progressBar"></div>
      </div>

      <button class="new-words-btn" id="newWordsBtn">üé≤ New Random Words</button>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>‚öôÔ∏è Settings</h2>
          <button class="close-btn" id="closeModalBtn">√ó</button>
        </div>
        <div class="modal-controls">
          <div class="modal-control-group">
            <label for="pauseDelay">Pause Before Recording (ms)</label>
            <input
              type="number"
              id="pauseDelay"
              value="2000"
              min="500"
              max="5000"
            />
          </div>
          <div class="modal-control-group">
            <label for="recordTime">Recording Duration (ms)</label>
            <input
              type="number"
              id="recordTime"
              value="3000"
              min="1000"
              max="8000"
            />
          </div>
          <div class="modal-control-group">
            <label for="playbackDelay">Delay After Playback (ms)</label>
            <input
              type="number"
              id="playbackDelay"
              value="1500"
              min="500"
              max="3000"
            />
          </div>
          <div class="modal-control-group">
            <label for="speechRate">Speech Rate (0.5 - 2.0)</label>
            <input
              type="range"
              id="speechRate"
              min="0.5"
              max="2"
              step="0.1"
              value="0.9"
            />
          </div>
          <div class="modal-control-group">
            <label for="initialDelay">Delay Before First Word (ms)</label>
            <input
              type="number"
              id="initialDelay"
              value="1000"
              min="0"
              max="3000"
            />
          </div>
        </div>
      </div>
    </div>

    <script>
      class PronunciationPractice {
        constructor() {
          // Array of 50 English words
          this.allWords = [
              'pronunciation', 'beautiful', 'chocolate', 'comfortable', 'vegetables',
              'temperature', 'international', 'definitely', 'beginning', 'appreciate',
              'achievement', 'adventure', 'algorithm', 'alliance', 'alternative',
              'ambulance', 'analysis', 'anniversary', 'announcement', 'anonymous',
              'apartment', 'appearance', 'application', 'appointment', 'appreciation',
              'appropriate', 'architecture', 'arrangement', 'assessment', 'assignment',
              'assistance', 'atmosphere', 'attention', 'attraction', 'authority',
              'availability', 'background', 'bankruptcy', 'basketball', 'battlefield',
              'bibliography', 'biological', 'birthplace', 'blackboard', 'blueprint',
              'bookkeeper', 'breakthrough', 'broadcast', 'brotherhood', 'butterfly'
          ];

          this.practiceWords = [];
          this.currentWordIndex = 0;
          this.isRunning = false;
          this.mediaRecorder = null;
          this.audioChunks = [];
          this.recordedAudio = null;

          this.initializeElements();
          this.setupEventListeners();
          this.checkBrowserSupport();
          this.generateRandomWords();
        }

        initializeElements() {
          this.wordDisplay = document.getElementById("wordDisplay");
          this.practiceInfo = document.getElementById("practiceInfo");
          this.startBtn = document.getElementById("startBtn");
          this.newWordsBtn = document.getElementById("newWordsBtn");
          this.settingsBtn = document.getElementById("settingsBtn");
          this.settingsModal = document.getElementById("settingsModal");
          this.closeModalBtn = document.getElementById("closeModalBtn");
          this.status = document.getElementById("status");
          this.progressBar = document.getElementById("progressBar");
          this.pauseDelayInput = document.getElementById("pauseDelay");
          this.recordTimeInput = document.getElementById("recordTime");
          this.playbackDelayInput = document.getElementById("playbackDelay");
          this.speechRateInput = document.getElementById("speechRate");
          this.initialDelayInput = document.getElementById("initialDelay");
        }

        setupEventListeners() {
          this.startBtn.addEventListener("click", () => {
            if (this.isRunning) {
              this.stopPractice();
            } else {
              this.startPractice();
            }
          });

          this.newWordsBtn.addEventListener("click", () => {
            if (!this.isRunning) {
              this.generateRandomWords();
            }
          });

          this.settingsBtn.addEventListener("click", () => {
            this.openModal();
          });

          this.closeModalBtn.addEventListener("click", () => {
            this.closeModal();
          });

          // Close modal when clicking outside
          this.settingsModal.addEventListener("click", (e) => {
            if (e.target === this.settingsModal) {
              this.closeModal();
            }
          });

          // Close modal with Escape key
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && this.settingsModal.classList.contains("show")) {
              this.closeModal();
            }
          });
        }

        checkBrowserSupport() {
          if (!("speechSynthesis" in window)) {
            this.updateStatus(
              "Speech synthesis not supported in this browser",
              "error",
            );
            this.startBtn.disabled = true;
            return;
          }

          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            this.updateStatus(
              "Microphone access not supported in this browser",
              "error",
            );
            this.startBtn.disabled = true;
            return;
          }
        }

        generateRandomWords() {
          // Fisher-Yates shuffle algorithm to get 10 random words
          const shuffled = [...this.allWords];
          for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
          }
          
          this.practiceWords = shuffled.slice(0, 10);
          this.currentWordIndex = 0;
          this.updatePracticeInfo();
          this.updateProgress(0);
          this.wordDisplay.textContent = "Ready to start!";
          this.updateStatus("Click START to begin with new words", "waiting");
        }

        updatePracticeInfo() {
          this.practiceInfo.textContent = `Practice 10 random words: ${this.practiceWords.join(', ')}`;
        }

        async startPractice() {
          if (this.isRunning) return;

          if (this.practiceWords.length === 0) {
            this.generateRandomWords();
          }

          this.isRunning = true;
          this.currentWordIndex = 0;
          this.startBtn.textContent = "STOP";
          this.startBtn.style.background =
            "linear-gradient(135deg, #e74c3c, #c0392b)";
          this.newWordsBtn.disabled = true;
          this.updateProgress(0);

          try {
            await this.requestMicrophonePermission();
            
            // Warm up speech synthesis (especially important for Android Chrome)
            await this.warmUpSpeechSynthesis();
            
            // Add initial delay before starting the first word
            if (this.isRunning) {
              await this.delay(
                parseInt(this.initialDelayInput.value),
                "Starting practice..."
              );
            }
            
            await this.practiceLoop();
          } catch (error) {
            console.error("Practice error:", error);
            this.updateStatus("Error: " + error.message, "error");
          } finally {
            this.resetPractice();
          }
        }

        async requestMicrophonePermission() {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: true,
            });
            stream.getTracks().forEach((track) => track.stop());
          } catch (error) {
            throw new Error("Microphone permission denied or not available");
          }
        }

        async practiceLoop() {
          while (
            this.currentWordIndex < this.practiceWords.length &&
            this.isRunning
          ) {
            const currentWord = this.practiceWords[this.currentWordIndex];
            this.wordDisplay.textContent = currentWord;
            this.updateProgress(
              (this.currentWordIndex / this.practiceWords.length) * 100,
            );

            // Play the word
            await this.speakWord(currentWord);

            if (!this.isRunning) break;

            // Pause
            await this.delay(
              parseInt(this.pauseDelayInput.value),
              "Preparing to record...",
            );

            if (!this.isRunning) break;

            // Record user pronunciation
            await this.recordUserAudio();

            if (!this.isRunning) break;

            // Play recorded audio
            await this.playRecordedAudio();

            if (!this.isRunning) break;

            // Delay before next word (skip for last word)
            if (this.currentWordIndex < this.practiceWords.length - 1) {
              await this.delay(
                parseInt(this.playbackDelayInput.value),
                "Next word coming up...",
              );
            }

            this.currentWordIndex++;
          }

          if (this.isRunning) {
            this.updateStatus("Practice completed! Great job! üéâ", "success");
            this.wordDisplay.textContent = "Practice Complete!";
            this.updateProgress(100);
          }
        }

        speakWord(word) {
          return new Promise((resolve) => {
            this.updateStatus(`üîä Listen: "${word}"`, "speaking");

            // Ensure any previous speech is cancelled
            if (speechSynthesis.speaking) {
              speechSynthesis.cancel();
            }

            // Wait a bit longer for Android Chrome compatibility
            setTimeout(() => {
              const utterance = new SpeechSynthesisUtterance(word);
              utterance.lang = "en-US";
              utterance.rate = parseFloat(this.speechRateInput.value);
              utterance.pitch = 1;
              utterance.volume = 1;

              // Set voice with better Android Chrome compatibility
              const voices = speechSynthesis.getVoices();
              if (voices.length > 0) {
                // Prioritize local voices for Android Chrome
                const englishVoice = voices.find(voice => 
                  voice.lang.startsWith('en') && voice.localService
                ) || voices.find(voice => 
                  voice.lang.startsWith('en')
                ) || voices[0];
                
                utterance.voice = englishVoice;
              }

              let hasEnded = false;
              
              utterance.onend = () => {
                if (!hasEnded) {
                  hasEnded = true;
                  setTimeout(resolve, 200); // Longer delay for Android Chrome
                }
              };
              
              utterance.onerror = (error) => {
                console.warn("Speech synthesis error for word:", word, error);
                if (!hasEnded) {
                  hasEnded = true;
                  setTimeout(resolve, 200);
                }
              };

              // Additional safety timeout for Android Chrome
              setTimeout(() => {
                if (!hasEnded) {
                  hasEnded = true;
                  console.warn("Speech synthesis timeout for word:", word);
                  resolve();
                }
              }, 5000); // 5 second timeout

              speechSynthesis.speak(utterance);
            }, 200); // Longer initial delay for Android Chrome
          });
        }

        playDingSound() {
          return new Promise((resolve) => {
            const audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.type = "sine";

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.3,
            );

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);

            oscillator.onended = () => {
              audioContext.close();
              resolve();
            };
          });
        }

        async recordUserAudio() {
          return new Promise(async (resolve, reject) => {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                  echoCancellation: true,
                  noiseSuppression: true,
                  sampleRate: 44100,
                },
              });

              this.audioChunks = [];
              this.mediaRecorder = new MediaRecorder(stream, {
                mimeType: MediaRecorder.isTypeSupported("audio/webm")
                  ? "audio/webm"
                  : "audio/mp4",
              });

              this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                  this.audioChunks.push(event.data);
                }
              };

              this.mediaRecorder.onstop = () => {
                const audioBlob = new Blob(this.audioChunks, {
                  type: "audio/wav",
                });
                this.recordedAudio = new Audio(URL.createObjectURL(audioBlob));
                stream.getTracks().forEach((track) => track.stop());
                resolve();
              };

              await this.playDingSound();

              if (!this.isRunning) {
                stream.getTracks().forEach((track) => track.stop());
                resolve();
                return;
              }

              this.updateStatus("üé§ Recording... Speak now!", "listening");
              this.mediaRecorder.start();

              setTimeout(() => {
                if (
                  this.mediaRecorder &&
                  this.mediaRecorder.state === "recording"
                ) {
                  this.mediaRecorder.stop();
                }
              }, parseInt(this.recordTimeInput.value));
            } catch (error) {
              reject(
                new Error("Failed to access microphone: " + error.message),
              );
            }
          });
        }

        async playRecordedAudio() {
          return new Promise((resolve) => {
            if (!this.recordedAudio) {
              resolve();
              return;
            }

            this.updateStatus("üîä Playing your recording...", "playing");

            this.recordedAudio.onended = () => resolve();
            this.recordedAudio.onerror = () => resolve();

            this.recordedAudio.play().catch(() => resolve());
          });
        }

        delay(ms, message = "Waiting...") {
          return new Promise((resolve) => {
            this.updateStatus(message, "waiting");
            setTimeout(resolve, ms);
          });
        }

        updateStatus(message, type = "") {
          this.status.textContent = message;
          this.status.className = `status ${type}`;
        }

        updateProgress(percentage) {
          this.progressBar.style.width = percentage + "%";
        }

        stopPractice() {
          this.isRunning = false;
          this.startBtn.textContent = "START";
          this.startBtn.style.background =
            "linear-gradient(135deg, #667eea, #764ba2)";
          this.newWordsBtn.disabled = false;
          this.updateStatus("Practice stopped", "waiting");

          if (speechSynthesis.speaking) {
            speechSynthesis.cancel();
          }

          if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
            this.mediaRecorder.stop();
          }

          if (this.recordedAudio && !this.recordedAudio.paused) {
            this.recordedAudio.pause();
            this.recordedAudio.currentTime = 0;
          }
        }

        resetPractice() {
          this.isRunning = false;
          this.startBtn.textContent = "START";
          this.startBtn.style.background =
            "linear-gradient(135deg, #667eea, #764ba2)";
          this.newWordsBtn.disabled = false;
          this.currentWordIndex = 0;

          if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
            this.mediaRecorder.stop();
          }

          if (this.recordedAudio && this.recordedAudio.src) {
            URL.revokeObjectURL(this.recordedAudio.src);
          }
        }
      }

      // Wait for voices to be loaded before initializing
      document.addEventListener("DOMContentLoaded", () => {
        if (speechSynthesis.getVoices().length > 0) {
          new PronunciationPractice();
        } else {
          speechSynthesis.addEventListener('voiceschanged', () => {
            new PronunciationPractice();
          }, { once: true });
        }
      });
    </script>
  </body>
</html>
